# -*- coding: utf-8 -*-
"""Coursework DMML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yr-KYO7ZAYTpG4GyyxUp3TTMgdylpT3M

# Loading Data
"""

# Commented out IPython magic to ensure Python compatibility.
import sys
assert sys.version_info >= (3, 5)
# Python ≥3.5 is required

# Scikit-Learn ≥0.20 is required
import sklearn
assert sklearn.__version__ >= "0.20"
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score

# Common imports
import numpy as np
import os
import tarfile
import urllib
import pandas as pd
import urllib.request
import seaborn as sns

# To plot pretty figures
# %matplotlib inline
import matplotlib as mpl
import matplotlib.pyplot as plt

# To get content
from google.colab import drive
drive.mount('/content/drive')

# pandas data
LeagueGames = pd.read_csv("/content/drive/MyDrive/high_diamond_ranked_10min.csv")

LeagueGames.head()
LeagueGames.info()

"""# Visualizing"""

#Histograms
LeagueGames.hist(bins=38, figsize=(20,15))
plt.show()

#Scatter graph of blue kills and blue deaths
LeagueGames.plot(kind="scatter", x='blueKills', y='blueDeaths', alpha=0.1)
plt.axis([0, 20, 0, 20])

#Scatter graph of blue kills and blue avg level
LeagueGames.plot(kind="scatter", x='blueKills', y='blueAvgLevel', alpha=0.1)
plt.axis([0, 20, 5, 10])

#Plot of blue kills, blue deaths to blue wins
LeagueJitter = LeagueGames[['blueKills','blueDeaths','blueWins']].copy()

LeagueJitter[['blueKills','blueDeaths']]

ax = sns.pairplot(LeagueJitter,hue="blueWins",height=2,plot_kws=dict(s=20,alpha=0.15,linewidth=2),palette=['red', 'blue'])

plt.figure(figsize=(15,20))
plt.show()

# Correlation Matrix
cor = LeagueGames[['blueWins','blueKills', 'blueDeaths', 'blueAssists', 'blueDragons', 'blueHeralds', 'blueTotalGold']].corr()

plt.figure(figsize=(20,10))
sns.heatmap(cor, annot=True)
plt.show()

"""#Preprocessing"""

# blue new KD diff
LeagueGames['blueKDDiff'] = LeagueGames['blueKills'] - LeagueGames['redKills']

# blue CS overall diff
LeagueGames['blueCSDiff'] = (LeagueGames['blueTotalMinionsKilled'] + LeagueGames['blueTotalJungleMinionsKilled']) - (LeagueGames['redTotalMinionsKilled'] + LeagueGames['redTotalJungleMinionsKilled'])

# blue vision score
LeagueGames['blueVisionScore'] = (LeagueGames['blueWardsPlaced'] + LeagueGames['blueWardsDestroyed'] - 0) - (LeagueGames['redWardsPlaced'] + LeagueGames['redWardsDestroyed'])

#Drop unneeded
LeagueGames.drop(['redExperienceDiff', 'redGoldDiff', 'redDeaths', 'blueDeaths', 'redFirstBlood', 'blueTotalExperience' , 'redTotalExperience','redTotalGold' , 'blueTotalGold', 'gameId'] , axis = 1, inplace = True)

# Remove Outliers
for column in [LeagueGames.columns]:

    mean = LeagueGames[column].mean()
    std = LeagueGames[column].std()
    threshold = std * 3

    lower =  mean - threshold
    upper =  mean + threshold

    LeagueGames = LeagueGames[(LeagueGames[column]) >= lower]
    LeagueGames = LeagueGames[(LeagueGames[column]) <= upper]

# Scaling
noScalingLeagueGames = LeagueGames.copy()
LeagueGamesTemp = LeagueGames

scaler = StandardScaler()
scaledLeague = pd.DataFrame(scaler.fit_transform(LeagueGames.drop('blueWins', axis = 1)), 
                       columns = LeagueGames.drop('blueWins', axis = 1).columns)

LeagueGames = scaledLeague
LeagueGames['blueWins'] = LeagueGamesTemp['blueWins']

# remove problematic
LeagueGames.dropna()
LeagueGames=LeagueGames[~LeagueGames.isin([np.nan, np.inf, -np.inf]).any(1)]

noScalingLeagueGames.dropna()
noScalingLeagueGames=noScalingLeagueGames[~noScalingLeagueGames.isin([np.nan, np.inf, -np.inf]).any(1)]
LeagueGames.head()

"""# Metrics"""

# Define print metrics for a model
#Used to print ROC curve and confusion matrix
def printMetrics(model,X_test, y_test, y_pred):
  cr=classification_report(y_test, y_pred)
  
  cm=confusion_matrix(y_test, y_pred)
  TP = cm[0][0]
  FN = cm[0][1]
  FP = cm[1][0]
  TN = cm[1][1]

  naive_probs = model.predict_proba(X_test)
  naive_probs = naive_probs[:,0]
  roc_auc = roc_auc_score(y_test, naive_probs)

  naive_tpr, naive_fpr, _ = roc_curve(y_test, naive_probs)


  print("Number of mislabeled points out of a total %d points : %d"% (X_test.shape[0], (y_test != y_pred).sum()))
  print()
  print(cr)
  print()
  print("True Positive: %d | False Negative: %d | False Positive: %d | True Negative: %d"% (TP, FN, FP, TN))
  print()
  print("AUROC: %f"% (roc_auc))
  print()
  plt.plot(naive_fpr, naive_tpr)
  plt.title("ROC Plot")
  plt.xlabel("False Positive")
  plt.ylabel("True Positive")
  print("____________________________________________________________________________________________")

#Return AUROC
def returnAUROC(model, data):

  x = gaussianBayes(data)


  model = x[0]
  X_test = x[1]
  y_test = x[2]
  y_pred = x[3]

  cr=classification_report(y_test, y_pred)
  
  cm=confusion_matrix(y_test, y_pred)
  TP = cm[0][0]
  FN = cm[0][1]
  FP = cm[1][0]
  TN = cm[1][1]

  naive_probs = model.predict_proba(X_test)
  naive_probs = naive_probs[:,1]
  roc_auc = roc_auc_score(y_test, naive_probs)

  return roc_auc

"""# Naive Bayes"""

# Define gaussian bayes function

def gaussianBayes(data):
  model = GaussianNB()
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.5, random_state=0)
  gaussianModel = model.fit(X_train, y_train)
  y_pred = model.fit(X_train, y_train).predict(X_test)
  

  return [gaussianModel,X_test, y_test, y_pred]

# do gaussian bayes and show how well it is

def displayGaussianBayes(data):
  x = gaussianBayes(data)
  printMetrics(x[0],x[1], x[2], x[3])

displayGaussianBayes(LeagueGames)

"""# Feature Selection Implementation"""

# Define number of features to be tested ~ 2 classes * 2 * 5 * 10

featureNumber = [4, 10, 30]


def featureExtractionTest(data,modelTested,featureExtractor):
  for x in featureNumber:
    print("Number of features: %d"% x)
    print(modelTested(featureExtractor(data, x)))

from sklearn.feature_selection import VarianceThreshold

# Variance Threshold feature selection

def varianceThreshold(data):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  select = VarianceThreshold(threshold = 0)
  x = select.fit(X)

  constant = [column for column in X.columns if column not in X.columns[x.get_support()]]
  newLeague = data.drop(constant, axis = 1)
  return newLeague

displayGaussianBayes(varianceThreshold(LeagueGames))

#from sklearn.feature_selection import SelectKBest, f_classif

# f_classification to get best features

#def fClass(data, k):

 # X = data.drop('blueWins', 1)
 # Y = data['blueWins']
  
  #select = SelectKBest(f_classif, k)
  #x = select.fit(X, Y)
  #constant = [column for column in X.columns if column not in X.columns[x.get_support()]]
  #newLeague = data.drop(constant, axis = 1)
  
  #return newLeague

#featureExtractionTest(LeagueGames,displayGaussianBayes, fClass)

from sklearn.feature_selection import SelectFromModel
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression

#random forest classification 
#feature selection using randmfores
def randomForest(data, k):

  X = data.drop('blueWins', 1)
  y = data['blueWins']
  
  rfc = SelectFromModel(RandomForestClassifier(n_estimators=100, random_state=1, max_features= k))
  rfc.fit(X, y)
  
  remove = [column for column in X.columns if column not in X.columns[rfc.get_support()]]

  new = data.drop(remove, axis = 1)
 
  return new

featureExtractionTest(LeagueGames,displayGaussianBayes, randomForest)

# Based on matrix
coorelationD = LeagueGames[['blueWins', 'blueGoldDiff', 'blueDragons', 'blueKills']]

displayGaussianBayes(coorelationD)

from sklearn.feature_selection import RFE
from sklearn.svm import LinearSVC

# Linear SVC Implementation to get features

def linearSVC(data, k):

  X = data.drop('blueWins', 1)
  y = data['blueWins']
  
  lsvc = LinearSVC(C=0.01, penalty="l1", dual=False)
  selector = SelectFromModel(lsvc, max_features = k)
  selector = selector.fit(X, y)
  
  remove = [column for column in X.columns if column not in X.columns[selector.get_support()]]

  new = data.drop(remove, axis = 1)
 
  return new

featureExtractionTest(LeagueGames,displayGaussianBayes, linearSVC)

from sklearn.ensemble import ExtraTreesClassifier

# Trees Classifier to get best features

def treesClassifier(data, k):

  X = data.drop('blueWins', 1)
  y = data['blueWins']
  
  clf = ExtraTreesClassifier(n_estimators=50, max_features = k)
  clf = clf.fit(X, y)
  selector = SelectFromModel(clf, prefit=True, max_features = k)

  remove = [column for column in X.columns if column not in X.columns[selector.get_support()]]

  new = data.drop(remove, axis = 1)

 
  return new

featureExtractionTest(LeagueGames,displayGaussianBayes, treesClassifier)

"""# Data Set Division based on Feature Extraction Implementation"""

# This funciton will extract the best data set using the previous feature selection implementation

# All multiple round based methods. It will return ROC score for each number of features, for every way of method extraction.
methods = [linearSVC, treesClassifier, randomForest]
featureNumber = [4, 10, 30]

def getBestDatasets(data, methodlist, featurelist):
  dataSets = []

  for number in featurelist:
    bestdf = LeagueGames
    bestAUROC = 0
    for method in methodlist:
      dataset = method(data, number)
      auroc = returnAUROC(GaussianNB, dataset)
      if auroc > bestAUROC:
        bestAUROC = auroc
        bestdf = dataset
    dataSets.append(bestdf)
    
  return dataSets

# Divide our dataset

leagueFourFeatures, leagueTenFeatures, leagueThirtyFeatures = getBestDatasets(LeagueGames, methods, featureNumber)

displayGaussianBayes(coorelationD)
displayGaussianBayes(leagueFourFeatures)
displayGaussianBayes(leagueTenFeatures)
displayGaussianBayes(leagueThirtyFeatures)

coorelationD.head()

leagueFourFeatures.head()

leagueTenFeatures.head()

leagueThirtyFeatures.head()

"""# **INTRO**

The dataset which I have chosen is “League of Legends Diamond Ranked Games (10 min)”. The dataset contains a lot of relevant information at the 10 minute mark of a game of League of Legends and which team won the game. Diamond is the rank of the game, meaning that all of the people in the match are good players and are competent. A game of League of Legends will last thirty or forty minutes. We can use the statistics available to us in the first 10 minutes of the game to see who will end up winning the match.

This was interesting for me specifically as a long time high-elo player of League of Legends. I wanted to see what good players do to win their games and how I can follow in their footsteps and be more likely to win my games in the long term.

Let me give an explanation of the game. League of Legends is a 5 versus 5 “multi online battle arena”. The 10 players are put into two teams of five - Red and Blue. Each team has a base called a nexus. The other team wins if they destroy the team’s nexus. The nexus is protected by multiple towers which must be beaten first before destroying the enemy team’s nexus. There are also “minions” which are small AIs which appear for both teams and automatically go to the nearest tower to destroy it. They are a source of income for the players. Players in league of legends can buy “items” with “gold”. Items make the character strong. Without items each character is weak. Getting gold involves killing the enemy minions / players / towers. There is also something called vision. Players can buy “wards” which are simply lamps that are used to grant vision of the map otherwise they will not see what is there. Lastly there are “dragons” which give the players big buffs if they kill them.

This is all interesting as we can see how a team is doing at the beginning of the long game by checking these metrics and then estimate what the outcome of the game will be based on which team has the most towers, gold and so forth in these early moments. I believe this data can be used in a professional analysis to help with people who are trying to become better at the video game or are playing for a professional league. This model will help tweak the plans of professional teams as they go into e-sports.

#**Visualisation**

In this section I used many visualisation methods to explore my data. The histograms showed me that the dataset is pretty balanced. We could see that 50% of the time the blue side wins and 50% of the time blue loses. This is the same with all binaries. First blood is split evenely between the teams too. The scatter plot showed me that the more kills blue has the less deaths they will have. Furthermore blue kills and average level seem to be linked. Using SNS pairplot we can see that the more kills then the more likely blue is to win. The correlation matrix showed me that the three most correlated features to wins is blue kills, blue total gold and blue assists. Blue heralds had very little correlation. More kills means more gold. More deaths means more likely to lose. With this all being said - the correlation between kills and wins is only 0.34 so that tells me that kills in the first 10 minutes of the game are not extremely significant.

#**Preprocessing**

For preprocessing I made many changes to make my data more useable. I introduced new features like KDDiff, CSDiff and visionScore. These are three separate attributes which are useful to tell how good a team is playing. KDDiff is difference in kills and deaths. CSDIff is how good the team is at getting non player enemies which will give gold. Vision Score is how good the team is at making dark areas of the map visible. I also dropped many features which were not necessary. GameID has no use. Many were the red features as they are usually the opposite of the blue team. I then used a scalar to scale my attributes. This is because there can be big differences in the attributes. Some attributes can be 0-10 and some can be 0-10000. Outliers were removed by calculating the mean for every feature and removing any record which had records 3 standard deviation away. Finally I checked for empty values and dropped.

#**Metrics**

I created three functions which I would use to measure the use of my models. Print metrics will show the TP, FP, TN, FN, Accuracy and ROC. This can be used on any model. After using this with naive bayes I can see that  the initial dataset has a precision of 0.71 and a ROC score of 0.792944. This gives me the impression that 10 minutes of the game is not enough data to be fully accurate when deciding who wins or loses the game.

#**Feature Selection**

I have used 6 different feature selection methods to try and get the best attributes from my dataset. The first is using variance threshold to reduce columns which have many repeating values. This had no impact on precision and had a ROC score of 0.207. I used the f_class algorithm which had a negative impact on precision and ROC. Next, random forest also yielded very similar results. I also tried to pick features myself based on my data visualisation and found that it increased ROC to 0.226 Linear SVC increased ROC score and recall for 2 * 2 attributes making me think this was the best algorithm. The trees classifier yielded similar results. I believe this is because of the naive classifier not taking into account that the features are correlated to each other. I found that the best feature selection method here was using the coorelation matrix as it gave the highest area ROC.

#**Conclusion**

I split my dataset into three datasets with 4, 10 and 30 columns each respectively (plus blueWins). I found that the dataset with 4 attributes was the best as it had a slightly better accuracy, recall and AUROC. I have realized however that this is not a massive difference from the original dataset. The conclusion I have come to is that 10 minutes is a good enough amount of data to predict what team will win with a 70-75% accuracy. This is not terrible but there is still many false positives and too false negatives - but this has a different conclusion that says a game is not over only based on the first minutes. This is good knowledge to know as many people in League say the game is lost too early and decide to leave the game. This data can be used to show us that actually a game is more flexible then you think. But if we really want to be fully precise then we should have more then only 10 minutes of the game.

# Clustering Visualization and Optimizing
"""

#This will help us plot the cluster
class Clusters():
    def __init__(self, cluster, data):
        self.cluster = cluster
        self.cluster_labels = cluster.labels_
        self.data = data.copy()
                
    def plot(self, xaxis, yaxis):
        fig = plt.plot(figsize = (11,9))
        
        self.data.insert(0, 'Clusters', self.cluster_labels)
        g = sns.scatterplot(data = self.data, x = xaxis, y = yaxis, hue = 'Clusters', alpha = 0.5, edgecolor = 'k', palette = 'viridis')

        plt.show()

#ELbow method to get best cluster k
from sklearn.metrics.pairwise import pairwise_distances_argmin
from sklearn.cluster import KMeans

def bestCluster(data):
  kin=[]

  for i in range(1,11): 
     kmeans = KMeans(n_clusters=i, init ='k-means++', n_init=10, random_state=0 )
     kmeans.fit(data)
     kin.append(kmeans.inertia_)

  plt.plot(range(1,11),kin)
  plt.title('The Elbow Method Graph')
  plt.xlabel('Number of clusters')
  plt.ylabel('Within-Cluster Sum of Square')
  plt.show()

bestCluster(noScalingLeagueGames)

from sklearn import metrics

def rand(t,f):
  print('Rand:', metrics.adjusted_rand_score(t, f))

#Fowlkes Mallows Score
def mallows(t,f):
  print('Fowlkes Mallows:', metrics.fowlkes_mallows_score(t, f))

#MutualInformation Score
def mutualInfo(t,f):
  print('Mutual Information: ', metrics.adjusted_mutual_info_score(t, f))

#Homogenity
def homo(t,f):
  print('Homogenity: ', metrics.homogeneity_score(t, f))

#Completeness
def completeness(t,f):
  print('Complete: ', metrics.completeness_score(t, f))

#CalinskiHarabasz
def calinskiHarabasz(X,labels):
  print('Harabasz:',metrics.calinski_harabasz_score(X, labels))

#Silhouette
def silhouette(X,labels):
  print('Silhouette: ', metrics.silhouette_score(X, labels, metric='euclidean'))

"""# KMeans Clustering"""

#k means clustering
def kMeansClustering(data, k):

  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  kmeans_model = KMeans(n_clusters=k, random_state=42).fit(X)
  predlabels = kmeans_model.labels_
  return [data, Y, predlabels]

k = kMeansClustering(noScalingLeagueGames, 2)

#Visualize cluster
def visualizeKMeansClustering(k, xaxis, yaxis):
  leagueCopy = noScalingLeagueGames.copy()

  kmeans= KMeans(n_clusters = k, random_state = 42).fit(leagueCopy.values)
  clusterp = Clusters(kmeans, leagueCopy)
  clusterp.plot(xaxis, yaxis)

visualizeKMeansClustering(3,'blueCSPerMin', 'blueGoldDiff')
visualizeKMeansClustering(4,'blueCSPerMin', 'blueGoldDiff')

visualizeKMeansClustering(3,'blueKills', 'blueVisionScore')
visualizeKMeansClustering(4,'blueKills', 'blueVisionScore')

visualizeKMeansClustering(3,'blueGoldDiff', 'blueTotalMinionsKilled')
visualizeKMeansClustering(4,'blueGoldDiff', 'blueTotalMinionsKilled')

#Accuracy of cluster
print('Two Clusters')
k = kMeansClustering(noScalingLeagueGames, 2)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\nThree Clusters')
k = kMeansClustering(noScalingLeagueGames, 3)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\nFour Clusters')
k = kMeansClustering(noScalingLeagueGames, 4)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\nFive Clusters')
k = kMeansClustering(noScalingLeagueGames, 5)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

"""# Mean Shift"""

#Mean shift clustering
from sklearn.cluster import MeanShift

def meanShiftClustering(data):
  X = data.drop('blueWins', 1)
  y = data['blueWins']
  k = sklearn.cluster.estimate_bandwidth(X,random_state=42)

  meanshift = MeanShift(bandwidth = k).fit(X)
  predict = meanshift.labels_

  return [X,y,predict]

#Visualize cluster
def visualizeMeanShiftClustering(xaxis, yaxis):
  leagueCopy = noScalingLeagueGames.copy()
  k = sklearn.cluster.estimate_bandwidth(leagueCopy.drop('blueWins',1),random_state=42)
  meanShift = MeanShift(bandwidth = k).fit(leagueCopy.values)
  MSc = Clusters(meanShift, leagueCopy)
  MSc.plot(xaxis, yaxis)


visualizeMeanShiftClustering('blueCSPerMin', 'blueGoldDiff')

visualizeMeanShiftClustering('blueVisionScore', 'blueGoldDiff')

#Accuracy of cluster
k = meanShiftClustering(noScalingLeagueGames)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

"""# Affinity Propagation"""

#Affinity propagation
from sklearn.cluster import AffinityPropagation

def affinityPropagationClustering(data,e):

  X = data.drop('blueWins', 1)
  y = data['blueWins']

  affinityprop = AffinityPropagation(damping=e,max_iter = 200)
  y_affp = affinityprop.fit_predict(X,y)
  
  return [X, y, y_affp]

#Visualize cluster
def visualizeAPCClustering(xaxis, yaxis,e):
  leagueCopy = noScalingLeagueGames.copy()

  app = AffinityPropagation(damping=e,max_iter=200).fit(leagueCopy.values)
  
  apfcluster = Clusters(app, leagueCopy)
  apfcluster.plot(xaxis, yaxis)

visualizeAPCClustering('blueCSPerMin','blueGoldDiff',0.52)
visualizeAPCClustering('blueCSPerMin','blueGoldDiff',0.75)

visualizeAPCClustering('blueGoldDiff','blueKDDiff',0.52)
visualizeAPCClustering('blueGoldDiff','blueKDDiff',0.75)

print('50% damping')
k = affinityPropagationClustering(noScalingLeagueGames, 0.5)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\n60% damping')
k = affinityPropagationClustering(noScalingLeagueGames, 0.6)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\n70% damping')
k = affinityPropagationClustering(noScalingLeagueGames, 0.7)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\n80% damping')
k = affinityPropagationClustering(noScalingLeagueGames, 0.8)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

"""# Spectral Shift"""

#Spectral Shift clustering
from sklearn.cluster import SpectralClustering
from sklearn.cluster import SpectralClustering
def spectralCluster(data,k):

  X = data.drop('blueWins', 1)
  y = data['blueWins']

  spectralc = SpectralClustering(n_clusters = k, random_state = 42).fit(X)
  spectral_y = spectralc.labels_
  
  return [X, y, spectral_y]

#Visualize cluster
def visualizeSpecteralC(xaxis, yaxis, k):
  leagueCopy = noScalingLeagueGames.copy()

  spectra = SpectralClustering(n_clusters = k,random_state = 42).fit(leagueCopy.values)
  
  SCluster = Clusters(spectra, noScalingLeagueGames)
  SCluster.plot(xaxis,yaxis)

visualizeSpecteralC('blueCSPerMin','blueGoldDiff',2)
visualizeSpecteralC('blueCSPerMin','blueGoldDiff',3)
visualizeSpecteralC('blueCSPerMin','blueGoldDiff',4)

#Accuracy of cluster
print('Two Clusters')
k = spectralCluster(noScalingLeagueGames, 2)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\nThree Clusters')
k = spectralCluster(noScalingLeagueGames, 3)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

print('\nFour Clusters')
k = spectralCluster(noScalingLeagueGames, 4)
rand(k[1],k[2])
mallows(k[1],k[2])
mutualInfo(k[1],k[2])
homo(k[1],k[2])
completeness(k[1],k[2])
calinskiHarabasz(k[0],k[1])
silhouette(k[0],k[1])

"""#**CLUSTERING**

#**Plotting**
I created a plotting method to plot my clusters. I go through the cluster labels which have all the points. These are then plotted with the viridis color scheme based on the cluster they are member of.
I used the elbow method to find the best number of clusters for k-means clustering. I found that using the elbow method the best number of clusters should be 4 clusters.
I used a bandwidth estimation algorithm to get the bandwidth for my meanshift clustering.

#**Statistics**
As for how I analyzed my clusters I used the following metrics.

**Using true and guess labels.**

Fowlkes Mallows:
The Fowlkes-Mallows score FMI is defined as the geometric mean of the pairwise precision and recall. Score ranges from 0 to 1. The higher the better.

Mutual Information:
Mutual Information measures the agreement of the labelling, ignoring permutations. From 0 to 1. The higher the better.

Homogenity:
Each cluster contains only members of a single class.

Completeness:
All members of a given class are assigned to the same cluster.

**True label-less**

Calinski-Harabasz:
Ratio of the sum of between-clusters dispersion and of within-cluster dispersion.

Silhouette:
The mean of a sample from all the points in its cluster and in the next cluster.

#**K-Means**
I used K Means clustering. K means clustering tries to reduce the within cluster sum of squares and seperate the data into a bunch of specified number of clusters. By subplotting the data we can see that the data is seperated into equal clusters and we can clearly see the differences between them.
We can see that using our different metrics that 2 clusters is the highest accuracy as according to fowlkes mallows and the rand score. We can see that K Means is not homogeonus and is not very high with completeness. It has a high Harabasz score and a low silhouette score.

#**Mean-Shift**
This method tries to find blobs around centers. Plotting the gold difference / cs per min we found only 1 blob. We found the same with blue gold dif and vision score.  We found that this technique gives a high fowlkes mallows score which means a high similarity. The clustering is not homegenius at all but is complete. Has a low silhouette score. Mutual information is unclear.

#**AP**
This clustering sends messages from a sample to another until convergence. From our plots we can see that there is very little space between the clusters. From our analysis 50% damping seems to be the best damping for this clustering as it has the highest mallow score and is complete. 60% damping has a low mallows score (10%) but better homogenity. The 70 and 80 percent are also the same. Mutual information is bad (0.05).

#**Spectral Clusters**
Spectral Clustering performs a low-dimension embedding of the affinity matrix between samples. We can see through our Clusters plot that even though multiple clusters are identified one is always dominating of the others. Regardless of the number of clusters asked to be identified the rand score is always very bad but the fowlkes score is solid. The Mutual information is low and the homogenus and completee index is also bad.

#**Bayes Comparison**
We can see that in comparison to the bayes classificaiton clustering did in fact work worse on average. Bayes got us around about 73 percent accuracy while clustering in different techniques fluctuated between 50 and 70% and in some cases gave us very low scores. The k means clustering technique was the closest in performance while the spectral shift clustering was the furthest.

#**Best Clustering Technique**
K Means was the best clustering method as it had the best mutual score and a good fowlkes score. We found that the best cluster k was actually 2 clusters which went against the plot of the elbow~method done earlier. All other methods faltered in mutual information. Affinity Propagation was the second best technique but only when damping with 50 percent dampness. Mean shift showed that blobs were unlikely to form in our data. Spectral shifting had a good fowlkes measure but was bad in other forms.

All the clusters had a 100 percent complete score except for spectral clusters which was not complete. The most homogenus cluster was affinity propagation with k means behind it. The other 2 were not homogenus.

In terms of plots k means and AP gave us the most meaningful results as we could our data being divided and parted in k means and we could see the distribution of clustering in affinity propagation clearly.

Overall the greatest clustering technique is k means but AP is also good.

# J48 Decision Tree on Training
"""

from sklearn.tree import DecisionTreeClassifier
#return the split
def returnTrainingTest(data,s):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=s, random_state=0)
  return [X_train, X_test, y_train, y_test]

from sklearn import tree
def J48Training(data,s,crit,split,maxD,maxF,minL,ccpa):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  
  tree_clf = DecisionTreeClassifier(criterion=crit, splitter=split,max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  treeFit = tree_clf.fit(X_train, y_train)
  y_pred = treeFit.predict(X_train)
  
  return [treeFit,X_train, y_train, y_pred]

#THIS is a default tree
x=J48Training(LeagueGames,0.5,"gini","best",None,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Criterion Test

x=J48Training(LeagueGames,0.5,"gini","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.5,"entropy","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.5,"gini","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.5,"gini","random",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Depth
for x in range(2,5):
  print("Depth:",x)
  x=J48Training(LeagueGames,0.5,"gini","best",x,None,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.5,"gini","best",10,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.5,"gini","best",20,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Features

for x in range(2,6):
  print("features:",x)
  x=J48Training(LeagueGames,0.5,"gini","best",2,x,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#Min leaf

for x in range(2,6):
  print("Leaf:",x)
  x=J48Training(LeagueGames,0.5,"gini","best",3,3,x,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#CCP Alpha
deez = [0.001,0.002,0.003,0.004]
for x in deez:
  print("ccp: ",x)
  x=J48Training(LeagueGames,0.5,"gini","best",4,3,6,x)
  printMetrics(x[0],x[1], x[2], x[3])

# Test Set proportions
x=J48Training(LeagueGames,0.3,"gini","best",4,2,4,0.003)
printMetrics(x[0],x[1], x[2], x[3])

x=J48Training(LeagueGames,0.6,"gini","best",4,2,4,0.003)
printMetrics(x[0],x[1], x[2], x[3])

"""# TenFold Cross Validation"""

from sklearn.model_selection import cross_val_score

def tenFoldTrain(data,s,crit,split,maxD,maxF,minL,ccpa,k):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  
  clf = DecisionTreeClassifier(criterion=crit, splitter=split,max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  scores = cross_val_score(clf, X_train, y_train, cv=k)

  return scores

#Unchanged Values
x=tenFoldTrain(LeagueGames,0.5,"gini","best",None,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

#Criterion

x=tenFoldTrain(LeagueGames,0.5,"entropy","best",3,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

x=tenFoldTrain(LeagueGames,0.5,"gini","best",3,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

#Splitter test
x=tenFoldTrain(LeagueGames,0.5,"gini","best",4,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

x=tenFoldTrain(LeagueGames,0.5,"gini","random",4,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

#Max epth
for x in range(2,6):
  print("FEATURES:  ",x)
  x=tenFoldTrain(LeagueGames,0.5,"gini","best",x,None,1,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#Max Features
for x in range(2,6):
  print("FEATURES:  ",x)
  x=tenFoldTrain(LeagueGames,0.5,"gini","best",2,x,1,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#Min Leaf
for x in range(2,7):
  print("Min leaf:",x,'\n')
  x=tenFoldTrain(LeagueGames,0.5,"gini","best",2,4,x,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#CCPA
deez = [0.001,0.002,0.003,0.004]
for x in deez:
  print("a:",x,'\n')
  x=tenFoldTrain(LeagueGames,0.5,"gini","best",4,4,2,x,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#Folds
for x in range(2,11):
  print("splits ",x,'\n')
  x=tenFoldTrain(LeagueGames,0.5,"gini","best",4,4,2,0,x)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

x=tenFoldTrain(LeagueGames,0.3,"gini","best",4,4,2,0,None)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean(),"]\n")

x=tenFoldTrain(LeagueGames,0.6,"gini","best",4,4,2,0,None)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean(),"]\n")

"""# J48 Decision Tree on Training and Test"""

def J48TrainTest(data,s,crit,split,maxD,maxF,minL,ccpa):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  
  tree_clf = DecisionTreeClassifier(criterion=crit, splitter=split,max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  treeFit = tree_clf.fit(X_train, y_train)
  y_pred = treeFit.predict(X_test)

  return [treeFit,X_test, y_test, y_pred]

#Default Settings
x=J48TrainTest(LeagueGames,0.5,"gini","best",None,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Criterion Test
x=J48TrainTest(LeagueGames,0.5,"gini","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.5,"entropy","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.5,"gini","best",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.5,"gini","random",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Depth
for x in range(2,5):
  print("Depth:",x)
  x=J48TrainTest(LeagueGames,0.5,"gini","best",x,None,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.5,"gini","best",10,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.5,"gini","best",20,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Features
for x in range(2,6):
  print("features:",x)
  x=J48TrainTest(LeagueGames,0.5,"gini","best",2,x,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#Leafs
for x in range(2,6):
  print("features:",x)
  x=J48TrainTest(LeagueGames,0.5,"gini","best",2,3,x,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#alpha
deez = [0.001,0.002,0.003,0.004]
for x in deez:
  print("ccp: ",x)
  x=J48TrainTest(LeagueGames,0.5,"gini","best",4,2,5,x)
  printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.3,"gini","best",4,2,5,0)
printMetrics(x[0],x[1], x[2], x[3])

x=J48TrainTest(LeagueGames,0.6,"gini","best",4,2,5,0)
printMetrics(x[0],x[1], x[2], x[3])

"""# Random Forest on Training"""

from sklearn import tree
def randomForestTraining(data,s,crit,maxD,maxF,minL,ccpa):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  
  tree_clf = RandomForestClassifier(criterion=crit, max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  treeFit = tree_clf.fit(X_train, y_train)
  y_pred = treeFit.predict(X_train)
  
  return [treeFit,X_train, y_train, y_pred]

#THIS is a default tree
x=randomForestTraining(LeagueGames,0.5,"gini",None,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Criterion Test
x=randomForestTraining(LeagueGames,0.5,"gini",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTraining(LeagueGames,0.5,"entropy",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Depth
for x in range(2,5):
  print("Depth:",x)
  x=randomForestTraining(LeagueGames,0.5,"gini",x,None,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTraining(LeagueGames,0.5,"gini",10,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTraining(LeagueGames,0.5,"gini",20,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Features
for x in range(2,6):
  print("features:",x)
  x=randomForestTraining(LeagueGames,0.5,"gini",2,x,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#min leaves
for x in range(2,6):
  print("features:",x)
  x=randomForestTraining(LeagueGames,0.5,"gini",2,2,x,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTraining(LeagueGames,0.3,"gini",2,2,4,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTraining(LeagueGames,0.6,"gini",2,2,4,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#alpha
deez = [0.001,0.002,0.003,0.06]
for x in deez:
  print("ccp: ", x)
  x=randomForestTraining(LeagueGames,0.5,"gini",4,2,4,x)
  printMetrics(x[0],x[1], x[2], x[3])

"""# Ten Fold Cross Validation Random Forest"""

def tenFoldForest(data,s,crit,maxD,maxF,minL,ccpa,k):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)

  clf = RandomForestClassifier(criterion=crit,max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  scores = cross_val_score(clf, X_train, y_train, cv=k)

  return scores

#Unchanged Values
x=tenFoldForest(LeagueGames,0.5,"gini",None,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

#Crit

x=tenFoldForest(LeagueGames,0.5,"entropy",3,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

x=tenFoldForest(LeagueGames,0.5,"gini",3,None,1,0.0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

#Max Features
for x in range(2,6):
  print("FEATURES:  ",x)
  x=tenFoldForest(LeagueGames,0.5,"gini",4,x,1,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#Features
for x in range(2,7):
  print("Min leaf:",x,'\n')
  x=tenFoldForest(LeagueGames,0.5,"gini",2,x,1,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#Min Leaf
for x in range(2,7):
  print("Min leaf:",x,'\n')
  x=tenFoldForest(LeagueGames,0.5,"gini",2,2,x,0.0,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

#CCPA
deez = [0.001,0.002,0.003,0.004]
for x in deez:
  print("a:",x,'\n')
  x=tenFoldForest(LeagueGames,0.5,"gini",4,2,6,x,10)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

x=tenFoldForest(LeagueGames,0.3,"gini",4,2,6,0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean(),"]\n")

x=tenFoldForest(LeagueGames,0.6,"gini",4,2,6,0,10)
print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean(),"]\n")

#Folds
for x in range(2,11):
  print("splits ",x,'\n')
  x=tenFoldForest(LeagueGames,0.5,"gini",4,4,2,0,x)
  print("Scores:\n",x,"\n")
  print("Score Aver:"," ",x.mean(),"]\n")

"""# Random Forest on Training and Test"""

from sklearn import tree
def randomForestTrainingTest(data,s,crit,maxD,maxF,minL,ccpa):
  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  
  tree_clf = RandomForestClassifier(criterion=crit, max_depth=maxD,max_features=maxF,
                                    min_samples_leaf = minL,random_state=42,ccp_alpha = ccpa)
  
  treeFit = tree_clf.fit(X_train, y_train)
  y_pred = treeFit.predict(X_test)
  
  return [treeFit,X_test, y_test, y_pred]

#THIS is a default tree
x=randomForestTrainingTest(LeagueGames,0.5,"gini",None,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Criterion Test
x=randomForestTrainingTest(LeagueGames,0.5,"gini",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTrainingTest(LeagueGames,0.5,"entropy",4,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Depth
for x in range(2,5):
  print("Depth:",x)
  x=randomForestTrainingTest(LeagueGames,0.5,"gini",x,None,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTrainingTest(LeagueGames,0.5,"gini",10,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTrainingTest(LeagueGames,0.5,"gini",20,None,1,0.0)
printMetrics(x[0],x[1], x[2], x[3])

#Max Features
for x in range(2,6):
  print("features:",x)
  x=randomForestTrainingTest(LeagueGames,0.5,"gini",2,x,1,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#Leaf
for x in range(2,6):
  print("leaff:",x)
  x=randomForestTrainingTest(LeagueGames,0.5,"gini",2,2,x,0.0)
  printMetrics(x[0],x[1], x[2], x[3])

#alpha
deez = [0.001,0.002,0.003,0.004]
for x in deez:
  print("ccp: ",x)
  x=randomForestTrainingTest(LeagueGames,0.5,"gini",4,2,6,x)
  printMetrics(x[0],x[1], x[2], x[3])

x=randomForestTrainingTest(LeagueGames,0.3,"gini",4,2,6,0)
printMetrics(x[0],x[1],x[2],x[3])

x=randomForestTrainingTest(LeagueGames,0.6,"gini",4,2,6,0)
printMetrics(x[0],x[1],x[2],x[3])

"""#***TREES***
#-----------
#**Decision Tree  Classifier using Training Set**
When testing the decision tree using my training set with default settings I found an accuracy of 100 percent due to the model getting too used to the training data. I tested both GINI and ENTROPY and found that Gini gave a better accuracy but there was barley any difference. Best also gave better performance over random by a couple of points. I found that 3 is the best depth for the tree. I experimented and found that when increasing the depth to 10 the accuracy is 84 percent and 20 d makes the accuracy 100% this is because the data is being fitted to the model overtly. I found the best number of max features to be 3 because 2 features is not enough and more features makes little difference. The number of min leaf I chose is 5 because it helps be more selective and does not impace performance. A alpha of 0.001 helped improve the tree slightly. Bigger numbers resulted in a 50% gini score. I noticed that when moving 30% of the data to the test set this resulted in a lower accuracy then when moving 60% of the data to the test set which means that the larger the test set has some overfitting issues (0.60 vs 0.68).

#**Ten Fold Cross Validation**
Testing this model with the default gave an accuracy of 61 percent. We can improve this. I found that both gini and ENTROPY gave very similar scores. Interestingly when reducing themaxdepth the accuracy of cross validation increased. I found that the best split method was more accurate than the random. The best max depth is 2. For some reason the deeper the depth the worse the accuracy. The more features the better, we will pick 5 as it is within the reasonable range and gives better performance than the others. The number of leafs needed made very little difference and so we chose a high number with 6. We faced the same issue with the alpha values as before so we used 0.001 as our pruning. The number of folds was tested. All folds from 2 to 10 gave the same or very similar result. Actually, when splitting up the training set I saw that 0.3% in the test set gave a higher accuracy - 0.69 percent - when compared to 0.6 which gave 0.66 percent.

#**Decision Tree Classifier using Training and Test**
We can see a great change from the very beginning. Default tree settings gives us 0.63% accuracy as opposed to 100% so we can see there is no overfitting. Gini was once again the better crit. Best gave the best split. Interestingly the higher the depth the worse the model worked. This is unlike the previous classifier and we found that a max depth of 2 was good. For max features the more the better but to avoid overfit we used 2 max features. The min number of leaves made litte difference but once again to avoid overfitting we chose a high number of 5. The best ccp was 0.002 but we saw little difference. We saw that putting 30% of the data into the test set gave us worse results but 3 percent.

#**Random Forest on Training**
We can see the same behavour where with default settings we get 100% accuracy. We find that both GINI and Entropy criterion are exactly the same in terms of precision recall and accuracy. As for depth, the more the better the model is. The depths from 2-6 give very close results so we will use 2. The model is not affected by the max number of features so we will use 2 as our max. The same with min leaves so we will use 5. We found the ccp value to have very little impact on our tree. Finally splitting our data into thirty precent and 60 percent made very little difference aswell.

#**Ten Fold RandomForest**
This tree performs slightly better than its counterpart with a point of 0.6853% however we still do not get the full 100 percent that we see when not using cross validation. Gini and entropy perform with no difference. The max number of features makes no difference so we choose 2. There is a very small difference between min leaf so we choose 6. We ignore CCP there is no difference. There is a very small difference between 30% and 60% in our test set. The best number of folds is 6.

#**Ten Fold Random TrainingTest**
We get an accuracy of 70% which is better than the counterpart but not 100. Gini and Entropy perform the same. We will use 3 as our depth as there is very little difference between them. No difference between number of max features, we use two. Small difference between the min leaf number - use 4. Alpha is negligable so we ignore. No difference between the percentage we use in our testing data.

#**Conclusion**
I noticed overfitting mainly when the depth of the tree was not controlled. In both instances when using the training data only we found that our tree or random forest tree gave us 100% accuracy which means the data is being matched perfectly which is wrong. I tried to eliminate over fitting by choosing the lowest great number for the minumum parameters and the highest number for the maximum. The tree does generalize well to new data getting about 70% accuracy which is the same as our naive bayes model.

# Linear Classifier
"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import cross_val_score
#return the split
def returnTrainingTest(data,s):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=s, random_state=0)
  return [X_train, X_test, y_train, y_test]

from sklearn.linear_model import SGDClassifier
def linearRegressor(data,s):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  clf = SGDClassifier(loss="log", max_iter=5)

  if s==0:
    X_train = X
    y_train = Y
    Fit = clf.fit(X_train, y_train)
    y_pred = Fit.predict(X_train)
    return [Fit,X_train, y_train, y_pred]

  else:
    X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
    Fit = clf.fit(X_train, y_train)
    y_pred = Fit.predict(X_test)
    return [Fit,X_test, y_test, y_pred]

x=linearRegressor(LeagueGames,0)
printMetrics(x[0],x[1], x[2], x[3])

x=linearRegressor(LeagueGames,0.3)
printMetrics(x[0],x[1], x[2], x[3])

"""# TenFold"""

from sklearn.linear_model import SGDClassifier
def linearRegressor10(data,s, foldsfat):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']

  clf = SGDClassifier(loss="log", max_iter=10)

  if s==0:
    X_train = X
    y_train = Y
    Fit = clf.fit(X_train, y_train)
    y_pred = Fit.predict(X_train)
    scores = cross_val_score(clf, X_train, y_train, cv=foldsfat)
    return scores

  else:
    X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
    Fit = clf.fit(X_train, y_train)
    y_pred = Fit.predict(X_test)
    scores = cross_val_score(clf, X_test, y_test, cv=foldsfat)
    return scores

x=linearRegressor10(LeagueGames,0,10)

print("Scores:\n",x,"\n")
print("Score Aver:"," ",x.mean())

x=linearRegressor10(LeagueGames,0.3,10)

print("Scores:",x)
print("Score:: ", x.mean())

"""# MultiLayer"""

from sklearn.neural_network import MLPClassifier
def mlp(data,s,activation,hiddenLayerSize,learnin,epoch,momentum,threshold):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']
  maxter=epoch
  clf = MLPClassifier(random_state=42, max_iter=maxter,hidden_layer_sizes=hiddenLayerSize,activation=activation
                      ,learning_rate=learnin,momentum=momentum,n_iter_no_change=threshold)

  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  Fit = clf.fit(X_train, y_train)
  y_pred = Fit.predict(X_test)
  return [Fit,X_test, y_test, y_pred]

#Default
mlpee=mlp(LeagueGames,0.3,'relu',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

#Function

print("Identity\n")
mlpee=mlp(LeagueGames,0.3,'identity',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("Tanh\n")
mlpee=mlp(LeagueGames,0.3,'tanh',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("Relu\n")
mlpee=mlp(LeagueGames,0.3,'relu',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("Logs\n")
mlpee=mlp(LeagueGames,0.3,'logistic',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

#Layers
print("20\n")
mlpee=mlp(LeagueGames,0.3,'identity',(20,20),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("50\n")
mlpee=mlp(LeagueGames,0.3,'identity',(50,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("100\n")
mlpee=mlp(LeagueGames,0.3,'identity',(100,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("20\n")
mlpee=mlp(LeagueGames,0.3,'identity',(200,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("400\n")
mlpee=mlp(LeagueGames,0.3,'identity',(400,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("adap adaptaation")
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print("inv")
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'invscaling',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print("constant\n")
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print("Max Iteration")
print(10)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',10,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print(20)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print(40)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',40,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print(80)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',80,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])
print(100)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',160,0.9,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

def mlpens(data,s,activation,hiddenLayerSize,learnin,epoch,momentum,threshold):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']
  maxter=epoch
  clf = MLPClassifier(random_state=42, solver='sgd', max_iter=maxter,hidden_layer_sizes=hiddenLayerSize,activation=activation
                      ,learning_rate=learnin,momentum=momentum,n_iter_no_change=threshold)

  X_train, X_test, y_train, y_test = returnTrainingTest(data,s)
  Fit = clf.fit(X_train, y_train)
  y_pred = Fit.predict(X_test)
  return [Fit,X_test, y_test, y_pred]

print(0.4)
mlpens=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.4,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print(0.5)
mlpens=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.5,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print(0.6)
mlpens=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.6,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print(0.7)
mlpens=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.7,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

print(0.8)
mlpee=mlp(LeagueGames,0.3,'identity',(20,),'adaptive',20,0.8,10)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

mlpee=mlp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,4)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

mlpee=mlp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,2)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

mlpee=mlp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,6)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

mlpee=mlp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,8)
printMetrics(mlpee[0],mlpee[1], mlpee[2], mlpee[3])

def deezMLp(data,s,activation,hiddenLayerSize,learnin,epoch,momentum,threshold,eeeeee):
  X = data.drop('blueWins', 1)
  Y = data['blueWins']
  maxter=epoch
  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=s, random_state=0)
  clf = MLPClassifier(random_state=42, max_iter=maxter,hidden_layer_sizes=hiddenLayerSize,activation=activation
                      ,learning_rate=learnin,momentum=momentum,n_iter_no_change=threshold)
  scores = cross_val_score(clf, X_test, y_test, cv=eeeeee)
  return scores

mlpee=deezMLp(LeagueGames,0.3,'identity',(20,),'constant',200,0.9,6,10)
print(mlpee.mean())

"""#***LINEAR REGRESSION***
The use of SGD regression on the dataset gave us an accuracy of 68.8% without splitting the data into test. When the data was split into test the accuracy 63 percent.

As for tenfold validation on it when not splitting any data into the test set the accuracy was 66%. After splitting the data into training and test a average of 60% was gotten.

The linear classer does not perform badly on new data as it only had a approximate 5.5 percent drop even linear classifier did perform worse then the other models.

The data is not linearly separable as convergence is not reached and it still has a relatively low accuracy.

#***Neural***


The score of the neural network is 70% at default stats.

We did some testing and found that identity and logarithm are both the same in terms of performance for activation function (71%). Relu performed ok at 70% and Tanh performed fine at 68%. Thus we can see that the activation functions improved performance. The activation function is what decided if the neuron should start or not.

 The relu made performance worse. Relu gets rid of neurons if the weight are under 0 and thus we can say that for our model we needed some weights to be under 0. The tan function is bad too as it is good for very leaned value.

As for the size we found that the best number and size is 20 and 30 but the difference was very little.
The learning rate made no difference in the model.
The best number of iterations was 40 increasing the accuracy by 15percent.

The threshold made very little difference. We did validation on the classifier. Momentum made no difference.
Overall the model is not extremely linearly seperable as it does not converge even after increasing the things that make it overfi. The model is better than a simple linear one though.
"""